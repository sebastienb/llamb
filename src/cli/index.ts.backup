#!/usr/bin/env node

// Import polyfills first
import '../utils/polyfills.js';

import { Command } from 'commander';
import chalk from 'chalk';
import OpenAI from 'openai';
import boxen from 'boxen';
import wrap from 'word-wrap';
import terminalLink from 'terminal-link';
import ora from 'ora';
import { marked } from 'marked';
//@ts-ignore
import TerminalRenderer from 'marked-terminal';
import hljs from 'highlight.js';
import path from 'path';
// Import inquirer directly now that we have polyfills
import inquirer from 'inquirer';
import { askQuestion, askQuestionWithStreaming, getModels, getProviders, getDefaultProvider, addProvider, setDefaultProvider, getProviderWithApiKey, deleteProvider } from '../services/llm.js';
import { KeyManager } from '../utils/keyManager.js';
import { SessionManager } from '../services/sessionManager.js';
import { readFile, writeFile, fileExists, generateUniqueFilename } from '../utils/fileUtils.js';
import config from '../config/index.js';
import { renderStreamingResponse } from '../components/StreamingResponse.js';
import { registerPromptCommands } from './promptCli.js';
import { processPrompt, formatQuestionWithPrompt } from '../services/promptExecution.js';

// Check for required system dependencies
function checkDependencies() {
  const { hasRequiredDeps, installCommand } = KeyManager.checkDependencies();
  if (!hasRequiredDeps) {
    console.error(chalk.red('Error: Missing system dependencies required for secure credential storage.'));
    console.error(chalk.yellow('To fix this issue, please install the required dependencies:'));
    console.error(chalk.cyan(installCommand));
    console.error(chalk.yellow('After installing dependencies, run: npm rebuild keytar'));
    console.error('');
    console.error(chalk.dim('You can still use local providers that don\'t require authentication.'));
    console.error('');
  }
  return hasRequiredDeps;
}

// Set up Terminal Renderer for markdown
// Need to use ts-ignore since the types for marked-terminal are problematic
//@ts-ignore
marked.setOptions({ renderer: new TerminalRenderer() });

const program = new Command();

// Check for dependencies on startup, but don't block operation
// This provides an early warning to users
checkDependencies();

// Read package version
import { readFileSync } from 'fs';
import * as readline from 'readline';
const packageJson = JSON.parse(readFileSync(new URL('../../package.json', import.meta.url), 'utf8'));

program
  .name('llamb')
  .description('CLI LLM client that answers questions directly from your terminal')
  .version(packageJson.version)
  .addHelpText('after', `
Examples:
  $ llamb "What is the capital of France?"     Ask a simple question
  $ llamb -f script.js "Explain this code"     Include a file with your question
  $ llamb "Summarize this" -f document.txt     Process file contents
  $ llamb -t summarize -f document.txt         Use a saved prompt template
  $ llamb "Generate JSON" -o                   Save response (prompts for filename)
  $ llamb "Generate JSON" -o result.json       Save response to a specific file
  $ llamb -n "What is 2+2?"                    Ask without using conversation history
  $ llamb -c "Tell me about France"            Start in continuous conversation mode
  $ llamb /history                             View conversation history
  $ llamb /clear                               Clear conversation history
  $ llamb /new                                 Start a new conversation
  $ llamb /debug                               Show terminal session debug info
  $ llamb /model                               Change the default model for current provider
  $ llamb model:default                        Select default model for the current provider
  $ llamb model:default -p openai              Select default model for a specific provider

Prompt Management:
  $ llamb prompt:list                          List all saved prompts
  $ llamb prompt:add <name>                    Create a new prompt template
  $ llamb prompt:edit <name>                   Edit a prompt template
  $ llamb prompt:delete <name>                 Delete a prompt template
  $ llamb prompt:show <name>                   Show a prompt template

Provider Management:
  $ llamb provider:add                         Add a new provider interactively
  $ llamb provider:edit                        Edit an existing provider interactively
  $ llamb provider:delete                      Delete a provider interactively
  $ llamb provider:apikey                      Update a provider's API key
  $ llamb provider:default                     Set the default provider
  $ llamb providers                            List all configured providers
  $ llamb provider:edit --name openai --url https://api.openai.com/v1 --model gpt-4o
                                               Edit a provider non-interactively
  $ llamb provider:delete --name openai        Delete a provider non-interactively
  $ llamb provider:delete --name openai --force Delete a provider without confirmation
`);

program
  .arguments('[question...]')
  .description('Ask a question to the LLM')
  .option('-c, --chat', 'Enable continuous conversation mode for follow-up questions')
  .option('--no-chat', 'Disable continuous conversation mode (default)')
  .option('-m, --model <model>', 'Specify the model to use')
  .option('-p, --provider <provider>', 'Specify the provider to use')
  .option('-u, --baseUrl <baseUrl>', 'Specify a custom base URL for this request')
  .option('-s, --stream', 'Stream the response as it arrives (default: true)')
  .option('--progress-only', 'Show progress indicator without streaming content (prevents scrollback artifacts)')
  .option('--live-stream', 'Force live streaming of content even if progress-only mode is enabled')
  .option('--ink', 'Use ink-based UI for rendering (prevents scrollback artifacts)')
  .option('--no-ink', 'Disable ink-based UI rendering (use traditional rendering)')
  .option('-n, --no-history', 'Do not use conversation history for this request')
  .option('-f, --file <path>', 'Path to a file to include with your question')
  .option('-o, --output [path]', 'Save the response to a file (will prompt for filename)')
  .option('-t, --prompt <name>', 'Use a saved prompt template for your question')
  .option('--overwrite', 'Overwrite existing files without prompting')
  .action(async (args, options) => {
    try {
      // Check for slash commands which should be handled directly
      if (args.length === 1 && args[0].startsWith('/')) {
        const slashCommand = args[0].substring(1);

        // Direct execution of slash commands without depending on Commander's command lookup
        switch (slashCommand) {
          case 'models':
            try {
              console.log(chalk.dim('Fetching models...'));
              const models = await getModels(options.provider);
              console.log(chalk.bold('Available Models:'));
              models.forEach(model => {
                console.log(`  ${model}`);
              });
            } catch (error: any) {
              console.error(chalk.red('Error:'), error.message);
            }
            return;

          case 'model':
            try {
              // Get the provider
              const providers = getProviders();
              const defaultProviderName = getDefaultProvider();
              const providerName = options.provider || defaultProviderName;

              // Find the provider
              const provider = providers.find(p => p.name === providerName);
              if (!provider) {
                console.log(chalk.yellow(`Provider '${providerName}' not found.`));
                return;
              }

              console.log(chalk.dim(`Fetching models for ${provider.name}...`));
              let models: string[] = [];

              try {
                models = await getModels(provider.name);
              } catch (error: any) {
                console.log(chalk.yellow(`Could not fetch models for ${provider.name}: ${error.message}`));
                console.log(chalk.yellow('You will need to enter the model name manually.'));
              }

              let modelAnswer;

              if (models.length > 0) {
                // Show current default model
                console.log(chalk.dim(`Current default model: ${provider.defaultModel}`));

                // Let user select from available models
                modelAnswer = await inquirer.prompt({
                  type: 'list',
                  name: 'model',
                  message: 'Select default model:',
                  choices: models,
                  default: models.findIndex(m => m === provider.defaultModel),
                });
              } else {
                // If we couldn't get models, let the user enter manually
                modelAnswer = await inquirer.prompt({
                  type: 'input',
                  name: 'model',
                  message: 'Enter default model name:',
                  default: provider.defaultModel,
                  validate: (input: string) => input.length > 0 ? true : 'Model name cannot be empty',
                });
              }

              // Update the provider's default model
              const updatedProvider = {
                ...provider,
                defaultModel: modelAnswer.model
              };

              // Add provider to update it (this replaces the existing entry)
              await addProvider(updatedProvider);
              console.log(chalk.green(`Default model for '${provider.name}' set to '${modelAnswer.model}'`));
            } catch (error: any) {
              console.error(chalk.red('Error:'), error.message);
            }
            return;

          case 'providers':
            try {
              const providers = getProviders();
              const defaultProvider = getDefaultProvider();

              console.log(chalk.bold('Configured Providers:'));

              let readyProviders = 0;

              // Check for stored API keys
              for (const provider of providers) {
                const isDefault = provider.name === defaultProvider;
                const hasApiKey = provider.noAuth ? true : await KeyManager.getApiKey(provider.name);
                const isReady = provider.noAuth || hasApiKey;

                if (isReady) readyProviders++;

                // Prefix with status indicators
                let prefix = isDefault ? chalk.green('* ') : '  ';

                // Color-code the provider name based on ready status
                const nameStyle = isReady ? chalk.bold : chalk.dim;
                let providerInfo = `${prefix}${nameStyle(provider.name)} - ${provider.baseUrl} ${chalk.dim(`(default model: ${provider.defaultModel})`)}`;

                // Add API key status
                if (provider.noAuth) {
                  providerInfo += ' ' + chalk.green('(ready to use)');
                } else if (hasApiKey) {
                  providerInfo += ' ' + chalk.green('(API key: ‚úì)');
                } else {
                  providerInfo += ' ' + chalk.yellow('(API key: ‚úó)');
                }

                console.log(providerInfo);
              }

              // Show help tips if no providers are ready to use
              if (readyProviders === 0) {
                console.log('');
                console.log(chalk.yellow('‚ö†Ô∏è  No providers are ready to use.'));
                console.log(chalk.cyan('To add an API key, run: ') + chalk.bold('llamb provider:apikey'));
                console.log(chalk.cyan('To add a new provider, run: ') + chalk.bold('llamb provider:add'));
                console.log('');
                console.log(chalk.green('Tip: If you have Ollama installed locally, you can use it without an API key.'));
              }
            } catch (error: any) {
              console.error(chalk.red('Error:'), error.message);
            }
            return;

          case 'clear':
            try {
              const sessionManager = SessionManager.getInstance();
              sessionManager.clearSession();
              console.log(chalk.green('Conversation context has been cleared.'));
            } catch (error: any) {
              console.error(chalk.red('Error:'), error.message);
            }
            return;

          case 'new':
            try {
              const sessionManager = SessionManager.getInstance();
              sessionManager.createNewSession();
              console.log(chalk.green('Started a new conversation context.'));
            } catch (error: any) {
              console.error(chalk.red('Error:'), error.message);
            }
            return;

          case 'history':
            try {
              const sessionManager = SessionManager.getInstance();
              const messages = sessionManager.getMessages();

              if (messages.length === 0) {
                console.log(chalk.yellow('No conversation history yet.'));
                return;
              }

              console.log(chalk.bold('Conversation History:'));
              console.log(chalk.dim(`Terminal ID: ${sessionManager.getTerminalId()}`));
              console.log('');

              // Get terminal width for the output box
              const terminalWidth = process.stdout.columns || 80;
              const maxWidth = Math.min(terminalWidth - 10, 100);

              // Display each message with appropriate styling
              messages.forEach((message, index) => {
                const roleColor = message.role === 'user' ? chalk.blue : chalk.green;
                const roleName = message.role === 'user' ? 'You' : 'Assistant';

                console.log(roleColor(chalk.bold(`${roleName}:`)));

                // Create a boxed message
                const boxedMessage = boxen(wrap(message.content, { width: maxWidth - 4, indent: '' }), {
                  padding: 1,
                  borderColor: message.role === 'user' ? 'blue' : 'green',
                  borderStyle: 'round',
                  width: maxWidth,
                });

                console.log(boxedMessage);

                // Add spacing between messages
                if (index < messages.length - 1) {
                  console.log('');
                }
              });
            } catch (error: any) {
              console.error(chalk.red('Error:'), error.message);
            }
            return;

          case 'debug':
            try {
              const sessionManager = SessionManager.getInstance();
              const terminalId = sessionManager.getTerminalId();

              console.log(chalk.bold('Terminal Session Debug Info:'));
              console.log('');
              console.log(chalk.cyan('Terminal ID:'), terminalId);
              console.log('');

              // Check if this is an SSH session
              const isSSH = process.env.SSH_CONNECTION ? true : false;
              console.log(chalk.cyan('Session Type:'), isSSH ? chalk.yellow('SSH Connection') : 'Local Terminal');

              if (isSSH) {
                console.log('');
                console.log(chalk.cyan('SSH Session Info:'));
                console.log(chalk.dim('SSH_CONNECTION:'), process.env.SSH_CONNECTION || 'not set');
                console.log(chalk.dim('SSH_CLIENT:'), process.env.SSH_CLIENT || 'not set');
                console.log(chalk.dim('SSH_TTY:'), process.env.SSH_TTY || 'not set');
              }

              console.log('');
              console.log(chalk.cyan('Environment Variables:'));
              console.log(chalk.dim('TERM_SESSION_ID:'), process.env.TERM_SESSION_ID || 'not set');
              console.log(chalk.dim('WINDOWID:'), process.env.WINDOWID || 'not set');
              console.log(chalk.dim('TERMINATOR_UUID:'), process.env.TERMINATOR_UUID || 'not set');
              console.log(chalk.dim('ITERM_SESSION_ID:'), process.env.ITERM_SESSION_ID || 'not set');
              console.log(chalk.dim('SHELL:'), process.env.SHELL || 'not set');
              console.log(chalk.dim('TTY:'), process.env.TTY || 'not set');
              console.log(chalk.dim('PID:'), process.pid?.toString() || 'not set');

              console.log('');
              console.log(chalk.cyan('Session Info:'));
              const currentSession = sessionManager.getCurrentSession();
              console.log(chalk.dim('Session ID:'), currentSession.id);
              console.log(chalk.dim('Created At:'), currentSession.createdAt);
              console.log(chalk.dim('Updated At:'), currentSession.updatedAt);
              console.log(chalk.dim('Message Count:'), currentSession.messages.length);

              console.log('');
              console.log(chalk.green('‚úì This command helps debug terminal-specific sessions.'));
              console.log(chalk.dim('Run this in different terminal windows to verify unique IDs.'));
            } catch (error: any) {
              console.error(chalk.red('Error:'), error.message);
            }
            return;
        }
      }

      if (args.length === 0 && !options.prompt) {
        console.log(chalk.yellow('No question provided. Use --help for usage information.'));
        return;
      }

      let question = args.join(' ');

      // Handle file input if provided
      let fileContent: string | undefined;
      if (options.file) {
        try {
          console.log(chalk.dim(`Reading file: ${options.file}`));
          fileContent = readFile(options.file);
          console.log(chalk.green(`‚úì File loaded (${(fileContent.length / 1024).toFixed(1)} KB)`));
        } catch (error: any) {
          console.error(chalk.red(`Error reading file: ${error.message}`));
          
          // Exit when done in non-chat mode with error code
          if (!options.chat) {
            exitWhenDone(1);
          }
          return;
        }
      }
      
      // Handle prompt template if specified
      if (options.prompt) {
        try {
          // Process the prompt with placeholders
          const processedPrompt = processPrompt(options.prompt, options.file, options.output);
          // Format the question with the prompt
          question = formatQuestionWithPrompt(question, processedPrompt);
        } catch (error: any) {
          console.error(chalk.red(`Error processing prompt: ${error.message}`));
          console.log(chalk.cyan('Available prompts:'));
          console.log(chalk.bold('  llamb prompt:list'));
          
          // Exit when done in non-chat mode with error code
          if (!options.chat) {
            exitWhenDone(1);
          }
          return;
        }
      }
          return;
        }
      }

      // If continuous conversation mode is enabled, use the specialized function
      if (options.chat) {
        console.log(chalk.dim('Starting continuous conversation mode...'));
        await startContinuousConversation(question, options, fileContent);
        return;
      }

      // Normal one-off question mode
      console.log(chalk.dim('Asking: ') + question);

      try {
        // Get list of providers and check if any exist
        const providers = getProviders();
        const defaultProviderName = getDefaultProvider();

        // If no providers are configured or no default provider is set
        if (providers.length === 0 || !defaultProviderName) {
          console.log(chalk.yellow('‚ö†Ô∏è  No providers configured yet.'));
          console.log('');

          // Provide helpful setup instructions without auto-launching anything
          console.log(chalk.cyan('To add a provider, you have several options:'));
          console.log('');
          console.log(chalk.bold('Option 1: Interactive setup (recommended for first-time users)'));
          console.log(chalk.bold('  llamb provider:add'));
          console.log('');
          console.log(chalk.bold('Option 2: Non-interactive setup for OpenAI'));
          console.log(chalk.bold('  llamb provider:add --name openai --url https://api.openai.com/v1 --model gpt-3.5-turbo --key YOUR_API_KEY'));
          console.log('');
          console.log(chalk.bold('Option 3: Non-interactive setup for Ollama (if installed locally)'));
          console.log(chalk.bold('  llamb provider:add --name ollama --url http://localhost:11434/v1 --model llama2'));
          console.log('');
          console.log(chalk.cyan('After adding a provider, you can try your question again:'));
          console.log(chalk.bold(`  llamb "${question}"`));
          return;
        }

        // Check if the provider has a valid API key if needed
        const provider = await getProviderWithApiKey(options.provider);

        if (!provider.noAuth && !provider.apiKey) {
          console.log(chalk.yellow(`‚ö†Ô∏è  Provider '${provider.name}' requires an API key but none is set.`));
          console.log(chalk.cyan('To add an API key interactively, run:'));
          console.log(chalk.bold('  llamb provider:apikey'));
          console.log(chalk.cyan('To add an API key non-interactively, run:'));
          console.log(chalk.bold(`  llamb provider:apikey --provider ${provider.name} --key YOUR_API_KEY`));
          console.log(chalk.cyan('To add a new provider, run:'));
          console.log(chalk.bold('  llamb provider:add'));
          console.log(chalk.cyan('To list available providers, run:'));
          console.log(chalk.bold('  llamb providers'));
          console.log('');

          // Check if any local provider is available as a fallback
          const localProviders = providers.filter(p => p.noAuth === true);
          if (localProviders.length > 0) {
            console.log(chalk.green(`You can use a local provider without an API key, for example:`));
            console.log(chalk.bold(`llamb -p ${localProviders[0].name} "${question}"`));
          }
          return;
        }
        
        // Get terminal width for the output box
        const terminalWidth = process.stdout.columns || 80;
        const maxWidth = Math.min(terminalWidth - 10, 100); // Account for padding and max reasonable width
        
        // Determine if we should stream (default to true unless explicitly set to false)
        const shouldStream = options.stream !== false;

        // Determine if we should use progress-only mode (prevents scrollback artifacts)
        // Check command-line options first, then fall back to config setting
        // --live-stream flag overrides both --progress-only and the config setting
        const useProgressOnly = options.liveStream === true ? false :
                              (options.progressOnly === true ||
                              (options.progressOnly !== false && config.get('useProgressOnly')));

        // Check if we should use the ink-based UI (enabled by default, can be disabled with --no-ink)
        const useInkUI = options.ink !== false && config.get('useInkUI') === true;

        let answer: string;
        
        if (shouldStream) {
          // If using Ink UI, it handles the streaming display
          if (useInkUI) {
            // Create an AbortController for cancellation support
            const abortController = new AbortController();

            // Create a streaming function for Ink to consume
            const streamingFunction = (onChunk: (chunk: string) => void) => {
              return askQuestionWithStreaming(
                question,
                onChunk,
                options.model,
                options.provider,
                options.baseUrl,
                options.history,
                fileContent,
                abortController
              );
            };

            // Use the ink-based UI for display with cancellation support
            const unmount = renderStreamingResponse(
              question,
              streamingFunction,
              (fullResponse: string) => {
                answer = fullResponse;
                // Handle file output when complete
                if (options.output !== undefined) {
                  try {
                    handleFileOutput(answer, options.output, options.overwrite);
                  } catch (error: any) {
                    console.error(chalk.red(`Error saving response: ${error.message}`));
                  }
                }
              },
              abortController
            );

            // Handle Ctrl+C during streaming
            process.on('SIGINT', () => {
              // Abort the request
              abortController.abort();
              // Unmount the UI
              unmount();
              console.log(chalk.red('\nRequest cancelled by user'));
              // Exit when done
              exitWhenDone();
            });

            // Early return since ink handles its own rendering
            return;
          } else if (useProgressOnly) {
            // PROGRESS-ONLY MODE: collect response and only render at the end
            // This eliminates all scrollback issues
            let partialResponse = '';
            let streamComplete = false;
            let updateCounter = 0;
            const streamInterval = 50; // ms between updates

            // Custom spinner alternating between lamb and llama emojis
            const animalEmojis = ['üêë', 'ü¶ô'];
            const spinner = ora({
              text: chalk.dim('Thinking...'),
              spinner: {
                frames: animalEmojis,
                interval: 400
              },
              color: 'yellow'
            }).start();

            // Display the question once
            console.log(chalk.dim('Asking: ') + question);

            // Collect the response through streaming without displaying intermediate updates
            const handleStreamingChunk = (chunk: string) => {
              partialResponse += chunk;
              updateCounter++;
            };

            // Start a timer that will update a progress indicator instead of the content
            const progressTimer = setInterval(() => {
              if (updateCounter > 0 && spinner.isSpinning) {
                spinner.text = chalk.dim(`Receiving response${'.'.repeat(updateCounter % 4)}`);
                updateCounter = 0;
              }

              if (streamComplete) {
                clearInterval(progressTimer);
              }
            }, streamInterval);

            // Set up the callback and ask the question
            answer = await askQuestionWithStreaming(
              question,
              handleStreamingChunk,
              options.model,
              options.provider,
              options.baseUrl,
              options.history,
              fileContent
            );

            // Mark streaming as complete and clear the interval
            streamComplete = true;
            clearInterval(progressTimer);

            // Stop the spinner
            spinner.stop();

            // Parse and display the full response at once
            //@ts-ignore
            const parsedResponse = marked(String(answer)) as string;
            const boxedResponse = boxen(parsedResponse, {
              padding: 1,
              borderColor: 'green',
              borderStyle: 'round',
              title: 'LLaMB',
              titleAlignment: 'center',
              width: maxWidth,
            });

            // Display the complete response once with no streaming artifacts
            console.log(boxedResponse);
          } else {
            // LIVE STREAMING MODE: show content as it arrives (may have scrollback artifacts)
            let partialResponse = '';
            let isFirstChunk = true;

            // Custom spinner alternating between lamb and llama emojis
            const animalEmojis = ['üêë', 'ü¶ô'];
            const spinner = ora({
              text: chalk.dim('Thinking...'),
              spinner: {
                frames: animalEmojis,
                interval: 400
              },
              color: 'yellow'
            }).start();

            // Display the question once
            console.log(chalk.dim('Asking: ') + question);

            // Function to create a clean render of the response
            const renderResponse = (content: string) => {
              // Parse markdown
              //@ts-ignore
              const parsedContent = marked(content) as string;

              // Create the boxed response
              return boxen(parsedContent, {
                padding: 1,
                borderColor: 'green',
                borderStyle: 'round',
                title: 'LLaMB',
                titleAlignment: 'center',
                width: maxWidth,
              });
            };

            // Track the state for terminal rendering
            let lastOutputLines = 0;

            // Process streaming content with live updates
            const handleStreamingChunk = (chunk: string) => {
              // Stop the spinner on first chunk
              if (isFirstChunk) {
                spinner.stop();
                isFirstChunk = false;
              }

              // Accumulate the response
              partialResponse += chunk;

              // Render the response and store its line count
              const rendered = renderResponse(partialResponse);
              const renderedLines = rendered.split('\n').length;

              // Logic for first render vs subsequent renders
              if (lastOutputLines === 0) {
                // First render after spinner stops
                process.stdout.write(rendered + '\n');
              } else {
                // For subsequent renders:
                // 1. Move cursor up to beginning of last output
                process.stdout.write(`\x1B[${lastOutputLines}A`);
                // 2. Clear screen from cursor down (removes old content)
                process.stdout.write('\x1B[J');
                // 3. Write new content
                process.stdout.write(rendered + '\n');
              }

              // Store line count for next update
              lastOutputLines = renderedLines;
            };

            // Set up the callback and ask the question
            answer = await askQuestionWithStreaming(
              question,
              handleStreamingChunk,
              options.model,
              options.provider,
              options.baseUrl,
              options.history,
              fileContent
            );
          }

          // Handle file output
          if (options.output !== undefined) {
            try {
              await handleFileOutput(answer, options.output, options.overwrite);
            } catch (error: any) {
              console.error(chalk.red(`Error saving response: ${error.message}`));
            }
          }
        } else {
          // Non-streaming version - show spinner alternating between lamb and llama
          const animalEmojis = ['üêë', 'ü¶ô'];
          const spinner = ora({
            text: chalk.dim('Thinking...'),
            spinner: {
              frames: animalEmojis,
              interval: 400
            },
            color: 'yellow'
          }).start();
          
          // Call without streaming
          answer = await askQuestion(question, options.model, options.provider, options.baseUrl, options.history, fileContent);
          
          // Stop the spinner
          spinner.stop();
          
          // Make sure answer is a string before parsing markdown
          const answerText = typeof answer === 'string' ? answer : String(answer);

          // Parse markdown and apply syntax highlighting
          // Need to cast result to string since marked types are problematic
          //@ts-ignore
          const parsedMarkdown = marked(answerText) as string;

          // Create a styled box for the answer
          const boxedAnswer = boxen(parsedMarkdown, {
            padding: 1,
            borderColor: 'green',
            borderStyle: 'round',
            title: 'LLaMB',
            titleAlignment: 'center',
            width: maxWidth,
          });

          console.log(boxedAnswer);

          // Handle file output
          if (options.output !== undefined) {
            try {
              await handleFileOutput(answerText, options.output, options.overwrite);
            } catch (error: any) {
              console.error(chalk.red(`Error saving response: ${error.message}`));
            }
          }

          // Exit when done in non-chat mode
          if (!options.chat) {
            exitWhenDone();
          }
        }
      } catch (error: any) {
        if (error.message.includes('No API key found')) {
          // Provide helpful setup instructions
          console.log(chalk.yellow('‚ö†Ô∏è  You need to configure an LLM provider.'));
          console.log(chalk.cyan('Add a provider: ') + chalk.bold('llamb provider:add'));
          
          // Check if Ollama is configured
          const providers = getProviders();
          const ollama = providers.find(p => p.name === 'ollama');
          if (ollama) {
            console.log(chalk.green(`Try Ollama: `) + chalk.bold(`llamb -p ollama "${question}"`));
          }
          exitWhenDone(1);
        } else if (error.message.includes('appears to be offline') || error.message.includes('unreachable')) {
          // Provider offline error
          console.log(chalk.yellow('‚ö†Ô∏è  ' + error.message));
          
          // Get all available providers to suggest alternatives
          const providers = getProviders();
          const currentProvider = providers.find(p => p.name === options.provider || getDefaultProvider());
          const otherProviders = providers.filter(p => p.name !== currentProvider?.name);
          
          if (otherProviders.length > 0) {
            let readyProviders = 0;
            for (const provider of otherProviders) {
              const hasApiKey = provider.noAuth ? true : await KeyManager.getApiKey(provider.name);
              if (hasApiKey || provider.noAuth) {
                console.log(chalk.cyan(`Try: `) + chalk.bold(`llamb -p ${provider.name} "${question}"`));
                readyProviders++;
                if (readyProviders >= 2) break; // Limit to just 2 suggestions
              }
            }
            
            if (readyProviders === 0) {
              console.log(chalk.cyan('Change provider: ') + chalk.bold('llamb provider:default'));
            }
          } else {
            console.log(chalk.cyan('Add new provider: ') + chalk.bold('llamb provider:add'));
          }
          exitWhenDone(1);
        } else if (error.message.includes('Failed to get response from')) {
          // General provider error
          console.log(chalk.yellow('‚ö†Ô∏è  ' + error.message));
          console.log(chalk.cyan('Try: ') + chalk.bold('llamb provider:default'));
          exitWhenDone(1);
        } else {
          console.error(chalk.red('Error:'), error.message);
          exitWhenDone(1);
        }
      }
    } catch (error: any) {
      console.error(chalk.red('Error:'), error.message);

      // Exit when done in non-chat mode with error code
      if (!options.chat) {
        exitWhenDone(1); // Exit with error code 1
      }
    }
  });

program
  .command('providers')
  .description('List configured LLM providers')
  .action(async () => {
    try {
      const providers = getProviders();
      const defaultProvider = getDefaultProvider();
      
      console.log(chalk.bold('Configured Providers:'));
      
      let readyProviders = 0;
      
      // Check for stored API keys
      for (const provider of providers) {
        const isDefault = provider.name === defaultProvider;
        const hasApiKey = provider.noAuth ? true : await KeyManager.getApiKey(provider.name);
        const isReady = provider.noAuth || hasApiKey;
        
        if (isReady) readyProviders++;
        
        // Prefix with status indicators
        let prefix = isDefault ? chalk.green('* ') : '  ';
        
        // Color-code the provider name based on ready status
        const nameStyle = isReady ? chalk.bold : chalk.dim;
        let providerInfo = `${prefix}${nameStyle(provider.name)} - ${provider.baseUrl} ${chalk.dim(`(default model: ${provider.defaultModel})`)}`;
        
        // Add API key status
        if (provider.noAuth) {
          providerInfo += ' ' + chalk.green('(ready to use)');
        } else if (hasApiKey) {
          providerInfo += ' ' + chalk.green('(API key: ‚úì)');
        } else {
          providerInfo += ' ' + chalk.yellow('(API key: ‚úó)');
        }
        
        console.log(providerInfo);
      }
      
      // Show help tips if no providers are ready to use
      if (readyProviders === 0) {
        console.log('');
        console.log(chalk.yellow('‚ö†Ô∏è  No providers are ready to use.'));
        console.log(chalk.cyan('To add an API key, run: ') + chalk.bold('llamb provider:apikey'));
        console.log(chalk.cyan('To add a new provider, run: ') + chalk.bold('llamb provider:add'));
        console.log('');
        console.log(chalk.green('Tip: If you have Ollama installed locally, you can use it without an API key.'));
      }
    } catch (error: any) {
      console.error(chalk.red('Error:'), error.message);
    }
  });

// Define common providers with their default settings
const commonProviders = [
  { 
    name: 'OpenAI', 
    value: 'openai',
    baseUrl: 'https://api.openai.com/v1',
    requiresApiKey: true,
    defaultModel: 'gpt-3.5-turbo'
  },
  { 
    name: 'Anthropic', 
    value: 'anthropic',
    baseUrl: 'https://api.anthropic.com/v1',
    requiresApiKey: true,
    defaultModel: 'claude-3-sonnet-20240229'
  },
  { 
    name: 'Mistral AI', 
    value: 'mistral',
    baseUrl: 'https://api.mistral.ai/v1',
    requiresApiKey: true,
    defaultModel: 'mistral-medium'
  },
  { 
    name: 'OpenRouter', 
    value: 'openrouter',
    baseUrl: 'https://openrouter.ai/api/v1',
    requiresApiKey: true,
    defaultModel: ''
  },
  { 
    name: 'Ollama (local)', 
    value: 'ollama',
    baseUrl: 'http://localhost:11434/v1',
    requiresApiKey: false,
    defaultModel: 'llama2'
  },
  { 
    name: 'LM Studio (local)', 
    value: 'lmstudio',
    baseUrl: 'http://localhost:1234/v1',
    requiresApiKey: false,
    defaultModel: ''
  },
  { 
    name: 'Other/Custom', 
    value: 'custom',
    baseUrl: '',
    requiresApiKey: false,
    defaultModel: ''
  }
];

program
  .command('provider:add')
  .description('Add or update a provider configuration')
  .option('--name <name>', 'Provider name (e.g., openai, anthropic, ollama)')
  .option('--url <url>', 'Base URL for the provider')
  .option('--key <apiKey>', 'API key for the provider (can be omitted for local providers)')
  .option('--model <model>', 'Default model for the provider')
  .action(async (options) => {
    try {
      // Check dependencies at the beginning
      const depsOk = checkDependencies();

      // Check if we're in non-interactive mode with all options provided
      if (options.name && options.url) {
        // Non-interactive mode
        console.log(chalk.green(`Setting up provider '${options.name}' in non-interactive mode...`));

        // Validate URL
        try {
          new URL(options.url);
        } catch (e) {
          console.error(chalk.red('Invalid URL format'));
          return;
        }

        // For local providers, mark them as noAuth
        const isLocalProvider = !options.key &&
          (options.name === 'ollama' ||
           options.name === 'lmstudio' ||
           options.url.includes('localhost') ||
           options.url.includes('127.0.0.1'));

        // If no model is provided, use defaults based on provider name
        let defaultModel = options.model || '';
        if (!defaultModel) {
          // Try to find a default model for known providers
          const knownProvider = commonProviders.find(p => p.value === options.name);
          defaultModel = knownProvider?.defaultModel || '';

          if (!defaultModel) {
            // Fallbacks for common providers
            if (options.name === 'openai') defaultModel = 'gpt-3.5-turbo';
            else if (options.name === 'anthropic') defaultModel = 'claude-3-sonnet-20240229';
            else if (options.name === 'mistral') defaultModel = 'mistral-medium';
            else if (options.name === 'ollama') defaultModel = 'llama2';
            else defaultModel = 'default'; // Generic fallback
          }
        }

        const answers = {
          name: options.name,
          baseUrl: options.url,
          apiKey: options.key || '',
          defaultModel: defaultModel,
          noAuth: isLocalProvider
        };

        // Store provider info and API key
        try {
          await addProvider(answers);

          // Set this provider as the default
          const currentDefault = getDefaultProvider();
          if (currentDefault !== answers.name) {
            setDefaultProvider(answers.name);
            console.log(chalk.green(`Provider '${answers.name}' added successfully and set as default provider`));
          } else {
            console.log(chalk.green(`Provider '${answers.name}' added successfully`));
          }

          if (answers.apiKey) {
            console.log(chalk.green('API key has been stored securely in your system keychain'));
          }
          return;
        } catch (error: any) {
          if (error.message.includes('Missing system dependencies')) {
            console.log(chalk.yellow('Provider configuration saved but API key storage failed.'));
            console.log(chalk.yellow('Please install the required dependencies and try again.'));
          } else {
            throw error;
          }
          return;
        }
      }

      // Interactive mode if not all options were provided
      // First select from common providers or custom
      const providerSelection = await inquirer.prompt([
        {
          type: 'list',
          name: 'provider',
          message: 'Select LLM provider:',
          choices: commonProviders.map(p => ({ name: p.name, value: p.value })),
        }
      ]);

      const selectedProvider = commonProviders.find(p => p.value === providerSelection.provider);

      // Then collect provider details, with pre-filled defaults
      const providerInfo = await inquirer.prompt([
        {
          type: 'input',
          name: 'name',
          message: 'Provider name:',
          default: selectedProvider?.value || '',
          validate: (input) => input.length > 0 ? true : 'Name cannot be empty',
        },
        {
          type: 'input',
          name: 'baseUrl',
          message: 'Base URL:',
          default: selectedProvider?.baseUrl || '',
          validate: (input) => {
            if (input.length === 0) return 'Base URL cannot be empty';
            try {
              // Validate URL using WHATWG URL API instead of punycode
              new URL(input);
              return true;
            } catch (e) {
              return 'Invalid URL format';
            }
          },
        },
        {
          type: 'input',
          name: 'apiKey',
          message: 'API Key' + (selectedProvider?.requiresApiKey ? '' : ' (can be left blank for local LLM servers)') + ':',
          default: '',
          validate: (input) => selectedProvider?.requiresApiKey && input.length === 0 ? 'API Key is required for this provider' : true,
        }
      ]);

      // Try to fetch available models
      console.log(chalk.dim('Fetching available models...'));

      let availableModels: string[] = [];

      try {
        // Create temporary OpenAI client to fetch models
        const openai = new OpenAI({
          apiKey: providerInfo.apiKey || 'dummy-key',
          baseURL: providerInfo.baseUrl,
        });

        const models = await openai.models.list();
        availableModels = models.data.map(model => model.id);

        if (availableModels.length > 0) {
          console.log(chalk.green(`Found ${availableModels.length} available models!`));
        }
      } catch (error) {
        console.log(chalk.yellow('Could not fetch models. You will need to enter the model name manually.'));
      }

      // Now prompt for model selection
      let defaultModelAnswer: { defaultModel: string };

      if (availableModels.length > 0) {
        defaultModelAnswer = await inquirer.prompt({
          type: 'list',
          name: 'defaultModel',
          message: 'Select default model:',
          choices: availableModels,
        });
      } else {
        defaultModelAnswer = await inquirer.prompt({
          type: 'input',
          name: 'defaultModel',
          message: 'Default model:',
          default: selectedProvider?.defaultModel || '',
          validate: (input: string) => input.length > 0 ? true : 'Default model cannot be empty',
        });
      }

      // For local providers, mark them as noAuth
      const isLocalProvider = !providerInfo.apiKey &&
        (selectedProvider?.value === 'ollama' ||
         selectedProvider?.value === 'lmstudio' ||
         providerInfo.baseUrl.includes('localhost') ||
         providerInfo.baseUrl.includes('127.0.0.1'));

      const answers = {
        name: providerInfo.name,
        baseUrl: providerInfo.baseUrl,
        apiKey: providerInfo.apiKey,
        defaultModel: defaultModelAnswer.defaultModel,
        noAuth: isLocalProvider
      };
      
      // Store provider info and API key securely
      try {
        await addProvider(answers);

        // Set this provider as the default
        const currentDefault = getDefaultProvider();
        if (currentDefault !== answers.name) {
          setDefaultProvider(answers.name);
          console.log(chalk.green(`Provider '${answers.name}' added/updated successfully and set as default provider`));
        } else {
          console.log(chalk.green(`Provider '${answers.name}' added/updated successfully`));
        }

        if (answers.apiKey) {
          console.log(chalk.green('API key has been stored securely in your system keychain'));
        }
      } catch (error: any) {
        if (error.message.includes('Missing system dependencies')) {
          // The detailed error message is already printed by the KeyManager
          console.log(chalk.yellow('Provider configuration saved but API key storage failed.'));
          console.log(chalk.yellow('Please install the required dependencies and try again.'));
        } else {
          throw error;
        }
      }
    } catch (error: any) {
      console.error(chalk.red('Error:'), error.message);
    }
  });

program
  .command('provider:apikey')
  .description('Update API key for a provider')
  .option('--provider <provider>', 'Provider name')
  .option('--key <apiKey>', 'API key for the provider')
  .action(async (options) => {
    try {
      // Check dependencies at the beginning
      const depsOk = checkDependencies();
      if (!depsOk) {
        console.error(chalk.yellow('Cannot proceed with API key operations until dependencies are installed.'));
        console.error(chalk.yellow('Please install the required dependencies and try again.'));
        return;
      }
      const providers = getProviders();
      if (providers.length === 0) {
        console.log(chalk.yellow('No providers configured. Add a provider first.'));
        return;
      }

      // Check if we're in non-interactive mode with all options provided
      console.log(chalk.dim(`Debug - provider: ${options.provider}, key: ${options.key ? 'provided' : 'not provided'}`));
      if (options.provider && options.key) {
        // Non-interactive mode
        console.log(chalk.green(`Setting API key for provider '${options.provider}' in non-interactive mode...`));

        // Verify the provider exists
        const provider = providers.find(p => p.name === options.provider);
        if (!provider) {
          console.error(chalk.red(`Provider '${options.provider}' not found.`));
          return;
        }

        // Store API key securely
        await KeyManager.storeApiKey(options.provider, options.key);
        console.log(chalk.green(`API key for '${options.provider}' updated successfully`));
        return;
      }

      // Interactive mode
      // Filter out providers marked as noAuth
      const authProviders = providers.filter(p => !p.noAuth);

      if (authProviders.length === 0) {
        console.log(chalk.yellow('No providers requiring authentication found.'));
        return;
      }

      // Choose provider
      const answers = await inquirer.prompt([
        {
          type: 'list',
          name: 'provider',
          message: 'Select provider to update API key:',
          choices: authProviders.map(p => p.name),
        },
        {
          type: 'input',
          name: 'apiKey',
          message: 'Enter new API key:',
          validate: (input) => input.length > 0 ? true : 'API Key cannot be empty',
        }
      ]);
      
      // Store API key securely
      await KeyManager.storeApiKey(answers.provider, answers.apiKey);
      console.log(chalk.green(`API key for '${answers.provider}' updated successfully`));
    } catch (error: any) {
      console.error(chalk.red('Error:'), error.message);
    }
  });

program
  .command('provider:default')
  .description('Set the default provider')
  .action(async () => {
    try {
      const providers = getProviders();
      if (providers.length === 0) {
        console.log(chalk.yellow('No providers configured. Add a provider first.'));
        return;
      }
      
      const answers = await inquirer.prompt([
        {
          type: 'list',
          name: 'provider',
          message: 'Select default provider:',
          choices: providers.map(p => p.name),
        },
      ]);
      
      setDefaultProvider(answers.provider);
      console.log(chalk.green(`Default provider set to '${answers.provider}'`));
    } catch (error: any) {
      console.error(chalk.red('Error:'), error.message);
    }
  });

program
  .command('provider:edit')
  .description('Edit an existing provider configuration')
  .option('--name <name>', 'Name of the provider to edit')
  .option('--url <url>', 'New base URL for the provider')
  .option('--key <apiKey>', 'New API key for the provider')
  .option('--model <model>', 'New default model for the provider')
  .action(async (options) => {
    try {
      // Check dependencies at the beginning
      checkDependencies();
      
      const providers = getProviders();
      if (providers.length === 0) {
        console.log(chalk.yellow('No providers configured. Add a provider first with:'));
        console.log(chalk.bold('  llamb provider:add'));
        return;
      }

      // Non-interactive mode
      if (options.name) {
        const provider = providers.find(p => p.name === options.name);
        if (!provider) {
          console.error(chalk.red(`Provider '${options.name}' not found.`));
          return;
        }

        // Update provider properties
        let updated = false;
        
        // Update URL if provided
        if (options.url) {
          try {
            new URL(options.url); // Validate URL
            provider.baseUrl = options.url;
            updated = true;
            console.log(chalk.green(`Provider URL updated to: ${options.url}`));
          } catch (e) {
            console.error(chalk.red('Invalid URL format'));
            return;
          }
        }
        
        // Update model if provided
        if (options.model) {
          provider.defaultModel = options.model;
          updated = true;
          console.log(chalk.green(`Default model updated to: ${options.model}`));
        }
        
        // If API key is provided, store it securely
        if (options.key) {
          try {
            await KeyManager.storeApiKey(provider.name, options.key);
            console.log(chalk.green('API key has been updated securely'));
            updated = true;
          } catch (keyError: any) {
            console.error(chalk.red('Error storing API key:'), keyError.message);
            return;
          }
        }
        
        if (updated) {
          // Save the updated provider
          await addProvider(provider);
          console.log(chalk.green(`Provider '${provider.name}' updated successfully`));
        } else {
          console.log(chalk.yellow('No changes were specified. Use --url, --model, or --key to specify changes.'));
        }
        
        return;
      }

      // Interactive mode - first select which provider to edit
      // Prepare choices with typed options
      const providerChoices = [
        ...providers.map(p => ({ name: p.name, value: p.name })),
        new inquirer.Separator(),
        { name: 'Cancel', value: 'cancel' }
      ];
      
      const providerSelection = await inquirer.prompt({
        type: 'list',
        name: 'name',
        message: 'Select provider to edit:',
        choices: providerChoices,
      });
      
      // Handle cancel option
      if (providerSelection.name === 'cancel') {
        console.log(chalk.yellow('Operation cancelled.'));
        return;
      }
      
      const selectedProvider = providers.find(p => p.name === providerSelection.name);
      if (!selectedProvider) {
        throw new Error('Selected provider not found');
      }
      
      // Ask for updated values
      const providerUpdates = await inquirer.prompt([
        {
          type: 'input',
          name: 'baseUrl',
          message: 'Base URL:',
          default: selectedProvider.baseUrl,
          validate: (input) => {
            if (input.length === 0) return 'Base URL cannot be empty';
            try {
              new URL(input);
              return true;
            } catch (e) {
              return 'Invalid URL format';
            }
          },
        },
        {
          type: 'confirm',
          name: 'updateApiKey',
          message: 'Do you want to update the API key?',
          default: false,
        },
        {
          type: 'password',
          name: 'apiKey',
          message: 'New API Key:',
          when: (answers) => answers.updateApiKey,
          validate: (input) => {
            if (selectedProvider.noAuth) return true;
            return input.length > 0 ? true : 'API Key cannot be empty';
          },
        }
      ]);
      
      // Try to fetch available models for the updated URL
      console.log(chalk.dim('Fetching available models...'));
      let availableModels: string[] = [];
      let modelAnswer: { defaultModel: string };
      
      try {
        // Create temporary OpenAI client to fetch models using the updated URL
        const openai = new OpenAI({
          apiKey: providerUpdates.apiKey || await KeyManager.getApiKey(selectedProvider.name) || 'dummy-key',
          baseURL: providerUpdates.baseUrl,
        });
        
        const models = await openai.models.list();
        availableModels = models.data.map(model => model.id);
        
        if (availableModels.length > 0) {
          console.log(chalk.green(`Found ${availableModels.length} available models!`));
          
          // Let user select from available models
          modelAnswer = await inquirer.prompt({
            type: 'list',
            name: 'defaultModel',
            message: 'Select default model:',
            choices: availableModels,
            default: availableModels.findIndex(m => m === selectedProvider.defaultModel),
          });
        } else {
          modelAnswer = await inquirer.prompt({
            type: 'input',
            name: 'defaultModel',
            message: 'Default model:',
            default: selectedProvider.defaultModel,
            validate: (input: string) => input.length > 0 ? true : 'Default model cannot be empty',
          });
        }
      } catch (error) {
        console.log(chalk.yellow('Could not fetch models. Using manual model configuration.'));
        
        modelAnswer = await inquirer.prompt({
          type: 'input',
          name: 'defaultModel',
          message: 'Default model:',
          default: selectedProvider.defaultModel,
          validate: (input: string) => input.length > 0 ? true : 'Default model cannot be empty',
        });
      }
      
      // Update the provider
      const updatedProvider = {
        ...selectedProvider,
        baseUrl: providerUpdates.baseUrl,
        defaultModel: modelAnswer.defaultModel
      };
      
      // Save the updated provider
      await addProvider(updatedProvider);
      console.log(chalk.green(`Provider '${selectedProvider.name}' updated successfully`));
      
      // If API key was provided, store it securely
      if (providerUpdates.updateApiKey && providerUpdates.apiKey) {
        await KeyManager.storeApiKey(selectedProvider.name, providerUpdates.apiKey);
        console.log(chalk.green('API key has been updated securely'));
      }
    } catch (error: any) {
      console.error(chalk.red('Error:'), error.message);
    }
  });

program
  .command('models')
  .description('List available models for a provider')
  .option('-p, --provider <provider>', 'Specify the provider to use')
  .action(async (options) => {
    try {
      console.log(chalk.dim('Fetching models...'));
      const models = await getModels(options.provider);

      console.log(chalk.bold('Available Models:'));
      models.forEach(model => {
        console.log(`  ${model}`);
      });
    } catch (error: any) {
      console.error(chalk.red('Error:'), error.message);
    }
  });

program
  .command('provider:delete')
  .description('Delete a provider configuration')
  .option('--name <name>', 'Name of the provider to delete')
  .option('--force', 'Skip confirmation prompt')
  .action(async (options) => {
    try {
      const providers = getProviders();
      if (providers.length === 0) {
        console.log(chalk.yellow('No providers configured.'));
        return;
      }
      
      // Non-interactive mode
      if (options.name) {
        const provider = providers.find(p => p.name === options.name);
        if (!provider) {
          console.error(chalk.red(`Provider '${options.name}' not found.`));
          return;
        }
        
        // Get confirmation unless --force is specified
        if (!options.force) {
          const confirm = await inquirer.prompt([
            {
              type: 'confirm',
              name: 'proceed',
              message: `Are you sure you want to delete provider '${options.name}'?`,
              default: false,
            }
          ]);
          
          if (!confirm.proceed) {
            console.log(chalk.yellow('Deletion cancelled.'));
            return;
          }
        }
        
        await deleteProvider(options.name);
        console.log(chalk.green(`Provider '${options.name}' has been deleted.`));
        
        // If there are providers left, show the new default
        const remainingProviders = getProviders();
        const newDefault = getDefaultProvider();
        if (remainingProviders.length > 0 && newDefault) {
          console.log(chalk.dim(`New default provider: ${newDefault}`));
        }
        
        return;
      }
      
      // Interactive mode - select provider to delete
      // Prepare choices with typed options
      const deleteChoices = [
        ...providers.map(p => ({ name: p.name, value: p.name })),
        new inquirer.Separator(),
        { name: 'Cancel', value: 'cancel' }
      ];
      
      const providerChoice = await inquirer.prompt({
        type: 'list',
        name: 'name',
        message: 'Select a provider to delete:',
        choices: deleteChoices,
      });
      
      // Handle cancel option
      if (providerChoice.name === 'cancel') {
        console.log(chalk.yellow('Operation cancelled.'));
        return;
      }
      
      // Get confirmation
      const confirmation = await inquirer.prompt([
        {
          type: 'confirm',
          name: 'proceed',
          message: `Are you sure you want to delete provider '${providerChoice.name}'?`,
          default: false,
        }
      ]);
      
      if (!confirmation.proceed) {
        console.log(chalk.yellow('Deletion cancelled.'));
        return;
      }
      
      // Delete the provider
      await deleteProvider(providerChoice.name);
      console.log(chalk.green(`Provider '${providerChoice.name}' has been deleted.`));
      
      // If there are providers left, show the new default
      const remainingProviders = getProviders();
      const newDefault = getDefaultProvider();
      if (remainingProviders.length > 0 && newDefault) {
        console.log(chalk.dim(`New default provider: ${newDefault}`));
      }
    } catch (error: any) {
      console.error(chalk.red('Error:'), error.message);
    }
  });

program
  .command('model:default')
  .description('Set the default model for a provider')
  .option('-p, --provider <provider>', 'Specify the provider to use')
  .action(async (options) => {
    try {
      // Get the provider
      const providers = getProviders();
      const defaultProviderName = getDefaultProvider();
      const providerName = options.provider || defaultProviderName;

      // Find the provider
      const provider = providers.find(p => p.name === providerName);
      if (!provider) {
        console.log(chalk.yellow(`Provider '${providerName}' not found.`));
        return;
      }

      console.log(chalk.dim(`Fetching models for ${provider.name}...`));
      let models: string[] = [];

      try {
        models = await getModels(provider.name);
      } catch (error: any) {
        console.log(chalk.yellow(`Could not fetch models for ${provider.name}: ${error.message}`));
        console.log(chalk.yellow('You will need to enter the model name manually.'));
      }

      let modelAnswer;

      if (models.length > 0) {
        // Show current default model
        console.log(chalk.dim(`Current default model: ${provider.defaultModel}`));

        // Let user select from available models
        modelAnswer = await inquirer.prompt({
          type: 'list',
          name: 'model',
          message: 'Select default model:',
          choices: models,
          default: models.findIndex(m => m === provider.defaultModel),
        });
      } else {
        // If we couldn't get models, let the user enter manually
        modelAnswer = await inquirer.prompt({
          type: 'input',
          name: 'model',
          message: 'Enter default model name:',
          default: provider.defaultModel,
          validate: (input: string) => input.length > 0 ? true : 'Model name cannot be empty',
        });
      }

      // Update the provider's default model
      const updatedProvider = {
        ...provider,
        defaultModel: modelAnswer.model
      };

      // Add provider to update it (this replaces the existing entry)
      await addProvider(updatedProvider);
      console.log(chalk.green(`Default model for '${provider.name}' set to '${modelAnswer.model}'`));

    } catch (error: any) {
      console.error(chalk.red('Error:'), error.message);
    }
  });

/**
 * Handle saving response to a file with interactive prompts
 */
async function handleFileOutput(content: string, outputPath: string | true, overwrite: boolean = false): Promise<void> {
  let finalPath = typeof outputPath === 'string' ? outputPath : '';

  // If no path is specified (just -o flag), prompt for a filename
  if (!finalPath) {
    const answer = await inquirer.prompt([
      {
        type: 'input',
        name: 'filename',
        message: 'Enter filename to save response:',
        default: `llamb-response-${Date.now()}.txt`,
        validate: (input: string) => input.length > 0 ? true : 'Filename cannot be empty'
      }
    ]);
    finalPath = answer.filename;
  }

  // Check if file exists and handle appropriately
  if (fileExists(finalPath) && !overwrite) {
    const answer = await inquirer.prompt([
      {
        type: 'list',
        name: 'action',
        message: `File '${finalPath}' already exists. What would you like to do?`,
        choices: [
          { name: 'Overwrite existing file', value: 'overwrite' },
          { name: 'Generate a new filename', value: 'new' },
          { name: 'Cancel', value: 'cancel' }
        ]
      }
    ]);

    if (answer.action === 'cancel') {
      console.log(chalk.yellow('File save cancelled.'));
      return;
    } else if (answer.action === 'new') {
      const newPath = generateUniqueFilename(finalPath);
      console.log(chalk.dim(`Using new filename: ${newPath}`));
      finalPath = newPath;
    }
    // For 'overwrite', we'll just continue with the existing path
  }

  // Write the file
  writeFile(finalPath, content, true); // true to overwrite if needed
  console.log(chalk.green(`‚úì Response saved to: ${finalPath}`));
}

// This handler is for unrecognized commands only
program.on('command:*', async (operands) => {
  const command = operands[0];
  console.log(chalk.yellow(`Unknown command: ${command}`));
  program.outputHelp();
});

// Add config management commands
program
  .command('config:progress-mode')
  .description('Toggle progress-only mode (prevents scrollback artifacts)')
  .option('--enable', 'Enable progress-only mode')
  .option('--disable', 'Disable progress-only mode')
  .option('--ink', 'Use ink-based UI (experimental)')
  .option('--status', 'Show current setting status (default)')
  .action((options) => {
    try {
      // Default to showing status if no action specified
      const showStatus = !options.enable && !options.disable && !options.ink;

      // Get current settings
      const currentProgressSetting = config.get('useProgressOnly');
      const currentInkSetting = config.get('useInkUI');

      if (options.enable) {
        // Enable progress-only mode
        config.set('useProgressOnly', true);
        // Disable ink when enabling progress-only mode
        config.set('useInkUI', false);
        console.log(chalk.green('Progress-only mode has been enabled.'));
        console.log(chalk.dim('This will prevent scrollback artifacts by not streaming content as it arrives.'));
      } else if (options.disable) {
        // Disable progress-only mode
        config.set('useProgressOnly', false);
        // Also disable ink when disabling progress-only mode
        config.set('useInkUI', false);
        console.log(chalk.green('Progress-only mode has been disabled.'));
        console.log(chalk.dim('Content will stream as it arrives (may have scrollback artifacts).'));
      } else if (options.ink) {
        // Enable ink UI mode
        config.set('useInkUI', true);
        // Disable progress-only mode when enabling ink
        config.set('useProgressOnly', false);
        console.log(chalk.green('Ink-based UI has been enabled.'));
        console.log(chalk.dim('Using React-based terminal UI, which prevents scrollback artifacts.'));
      }

      // Show status
      if (showStatus || options.status) {
        console.log(chalk.bold('Current settings:'));

        if (currentInkSetting) {
          console.log(chalk.green('‚úì Ink-based UI is enabled'));
          console.log(chalk.dim('Using React-based terminal UI to prevent scrollback artifacts.'));
        } else if (currentProgressSetting) {
          console.log(chalk.green('‚úì Progress-only mode is enabled'));
          console.log(chalk.dim('Content is not streamed as it arrives, preventing scrollback artifacts.'));
        } else {
          console.log(chalk.yellow('‚úó Progress-only mode is disabled'));
          console.log(chalk.dim('Content streams as it arrives (may have scrollback artifacts).'));
        }

        console.log('');
        console.log(chalk.cyan('To change these settings, use:'));
        console.log('  llamb config:progress-mode --enable   (progress-only mode)');
        console.log('  llamb config:progress-mode --ink      (experimental ink UI)');
        console.log('  llamb config:progress-mode --disable  (live streaming)');
      }
    } catch (error: any) {
      console.error(chalk.red('Error:'), error.message);
    }
  });

// Add reset/delete command
program
  .command('reset')
  .description('Reset all data (providers, settings, and conversation history)')
  .action(async () => {
    try {
      console.log(chalk.yellow('‚ö†Ô∏è  This will delete all LLaMB data:'));
      console.log('');
      console.log('  - All provider configurations');
      console.log('  - All API keys stored in your system keychain');
      console.log('  - All conversation history');
      console.log('  - All UI preferences and settings');
      console.log('');

      // Ask for confirmation
      const answer = await inquirer.prompt([
        {
          type: 'confirm',
          name: 'confirm',
          message: 'Are you sure you want to delete all LLaMB data?',
          default: false,
        }
      ]);

      if (!answer.confirm) {
        console.log(chalk.cyan('Reset cancelled.'));
        return;
      }

      // Delete all data
      try {
        // Clear provider configurations and settings
        config.clear();

        // Reinitialize with empty defaults to ensure proper schema
        config.set('providers', []);
        config.set('defaultProvider', '');
        config.set('useProgressOnly', false);
        config.set('useInkUI', true);

        // Clear all conversation sessions
        const sessionManager = SessionManager.getInstance();
        sessionManager.clearAllSessions();

        // Clear API keys for all providers
        const providers = getProviders();
        for (const provider of providers) {
          await KeyManager.deleteApiKey(provider.name);
        }

        console.log(chalk.green('‚úì All LLaMB data has been deleted successfully.'));
        console.log(chalk.green('You can start fresh by running:'));
        console.log(chalk.bold('  llamb "your question"'));
      } catch (error: any) {
        console.error(chalk.red('Error during reset:'), error.message);
      }
    } catch (error: any) {
      console.error(chalk.red('Error:'), error.message);
    }
  });

// Add context management commands
program
  .command('context:clear')
  .description('Clear the current conversation context')
  .action(() => {
    try {
      const sessionManager = SessionManager.getInstance();
      sessionManager.clearSession();
      console.log(chalk.green('Conversation context has been cleared.'));
    } catch (error: any) {
      console.error(chalk.red('Error:'), error.message);
    }
  });

program
  .command('context:new')
  .description('Start a new conversation context')
  .action(() => {
    try {
      const sessionManager = SessionManager.getInstance();
      sessionManager.createNewSession();
      console.log(chalk.green('Started a new conversation context.'));
    } catch (error: any) {
      console.error(chalk.red('Error:'), error.message);
    }
  });

program
  .command('context:history')
  .description('Display the current conversation history')
  .action(() => {
    try {
      const sessionManager = SessionManager.getInstance();
      const messages = sessionManager.getMessages();

      if (messages.length === 0) {
        console.log(chalk.yellow('No conversation history yet.'));
        return;
      }

      console.log(chalk.bold('Conversation History:'));
      console.log(chalk.dim(`Terminal ID: ${sessionManager.getTerminalId()}`));
      console.log('');

      // Get terminal width for the output box
      const terminalWidth = process.stdout.columns || 80;
      const maxWidth = Math.min(terminalWidth - 10, 100);

      // Display each message with appropriate styling
      messages.forEach((message, index) => {
        const roleColor = message.role === 'user' ? chalk.blue : chalk.green;
        const roleName = message.role === 'user' ? 'You' : 'Assistant';

        console.log(roleColor(chalk.bold(`${roleName}:`)));

        // Create a boxed message
        const boxedMessage = boxen(wrap(message.content, { width: maxWidth - 4, indent: '' }), {
          padding: 1,
          borderColor: message.role === 'user' ? 'blue' : 'green',
          borderStyle: 'round',
          width: maxWidth,
        });

        console.log(boxedMessage);

        // Add spacing between messages
        if (index < messages.length - 1) {
          console.log('');
        }
      });
    } catch (error: any) {
      console.error(chalk.red('Error:'), error.message);
    }
  });

/**
 * Explicit function to exit the app in non-chat mode
 * This ensures consistent behavior across all code paths
 * @param exitCode Optional exit code (0 for success, non-zero for errors)
 */
function exitWhenDone(exitCode: number = 0) {
  if (!process.env.LLAMB_DEBUG) {
    // Add a small delay to make sure console output is flushed
    setTimeout(() => {
      process.exit(exitCode);
    }, 300);
  }
}

/**
 * Custom prompt function using readline instead of inquirer
 * This avoids issues with Ctrl+C interruption in inquirer
 */
function customPrompt(prompt: string): Promise<string> {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
    terminal: true
  });

  return new Promise((resolve, reject) => {
    rl.question(chalk.bold(prompt) + ' ', (answer) => {
      rl.close();
      resolve(answer);
    });

    // Handle Ctrl+C properly
    rl.on('SIGINT', () => {
      rl.close();
      console.log(chalk.yellow('\nConversation interrupted.'));
      console.log(chalk.green('Thanks for using LLaMB!'));
      // Throw error instead of process.exit to allow proper cleanup in parent function
      reject(new Error('User force closed the prompt'));
    });
  });
}

// Add debug command for terminal session info
program
  .command('context:debug')
  .description('Display terminal and session debugging information')
  .action(() => {
    try {
      const sessionManager = SessionManager.getInstance();
      const terminalId = sessionManager.getTerminalId();

      console.log(chalk.bold('Terminal Session Debug Info:'));
      console.log('');
      console.log(chalk.cyan('Terminal ID:'), terminalId);
      console.log('');

      // Check if this is an SSH session
      const isSSH = process.env.SSH_CONNECTION ? true : false;
      console.log(chalk.cyan('Session Type:'), isSSH ? chalk.yellow('SSH Connection') : 'Local Terminal');

      if (isSSH) {
        console.log('');
        console.log(chalk.cyan('SSH Session Info:'));
        console.log(chalk.dim('SSH_CONNECTION:'), process.env.SSH_CONNECTION || 'not set');
        console.log(chalk.dim('SSH_CLIENT:'), process.env.SSH_CLIENT || 'not set');
        console.log(chalk.dim('SSH_TTY:'), process.env.SSH_TTY || 'not set');
      }

      console.log('');
      console.log(chalk.cyan('Environment Variables:'));
      console.log(chalk.dim('TERM_SESSION_ID:'), process.env.TERM_SESSION_ID || 'not set');
      console.log(chalk.dim('WINDOWID:'), process.env.WINDOWID || 'not set');
      console.log(chalk.dim('TERMINATOR_UUID:'), process.env.TERMINATOR_UUID || 'not set');
      console.log(chalk.dim('ITERM_SESSION_ID:'), process.env.ITERM_SESSION_ID || 'not set');
      console.log(chalk.dim('SHELL:'), process.env.SHELL || 'not set');
      console.log(chalk.dim('TTY:'), process.env.TTY || 'not set');
      console.log(chalk.dim('PID:'), process.pid?.toString() || 'not set');

      console.log('');
      console.log(chalk.cyan('Session Info:'));
      const currentSession = sessionManager.getCurrentSession();
      console.log(chalk.dim('Session ID:'), currentSession.id);
      console.log(chalk.dim('Created At:'), currentSession.createdAt);
      console.log(chalk.dim('Updated At:'), currentSession.updatedAt);
      console.log(chalk.dim('Message Count:'), currentSession.messages.length);

      console.log('');
      console.log(chalk.green('‚úì This command helps debug terminal-specific sessions.'));
      console.log(chalk.dim('Run this in different terminal windows to verify unique IDs.'));
    } catch (error: any) {
      console.error(chalk.red('Error:'), error.message);
    }
  });

// Add a special debug command for testing
program
  .command('force-reset')
  .description('Force reset all data without confirmation (debug command)')
  .action(async () => {
    try {
      console.log(chalk.yellow('Resetting all LLaMB data without confirmation (debug mode)...'));

      // Clear provider configurations and settings
      config.clear();

      // Reinitialize with empty defaults to ensure proper schema
      config.set('providers', []);
      config.set('defaultProvider', '');
      config.set('useProgressOnly', false);
      config.set('useInkUI', true);

      // Clear all conversation sessions
      const sessionManager = SessionManager.getInstance();
      sessionManager.clearAllSessions();

      // Clear API keys for all providers
      const providers = getProviders();
      for (const provider of providers) {
        await KeyManager.deleteApiKey(provider.name);
      }

      console.log(chalk.green('‚úì All LLaMB data has been deleted successfully.'));
    } catch (error: any) {
      console.error(chalk.red('Error during reset:'), error.message);
    }
  });

// Add a special debug command to set API key directly
program
  .command('apikey-direct <provider> <key>')
  .description('Set API key directly (debug command)')
  .action(async (provider, key) => {
    try {
      console.log(`Setting API key for ${provider} to: ${key}`);
      const providers = getProviders();
      const providerExists = providers.find(p => p.name === provider);

      if (!providerExists) {
        console.error(chalk.red(`Provider '${provider}' not found.`));
        return;
      }

      await KeyManager.storeApiKey(provider, key);
      console.log(chalk.green(`API key for '${provider}' set successfully!`));
    } catch (error: any) {
      console.error(chalk.red('Error:'), error.message);
    }
  });

// Continuous conversation mode function
async function startContinuousConversation(
  initialQuestion: string,
  options: any,
  fileContent?: string
) {
  let conversationActive = true;
  let currentQuestion = initialQuestion;
  let currentFileContent = fileContent;

  // Force disable Ink UI in continuous conversation mode to avoid issues
  if (options.ink !== false) {
    console.log(chalk.dim('Note: Ink UI is disabled in continuous conversation mode for better terminal compatibility.'));
    options.ink = false;
  }

  // Start the conversation with the initial question
  try {
    await handleQuestion(currentQuestion, options, currentFileContent);

    // Continue the conversation until the user exits
    while (conversationActive) {
      // Prompt for the next question
      try {
        console.log(chalk.dim('Ready for follow-up questions. Type /exit to end the conversation.'));
        const followUp = await customPrompt('ü¶ô Follow-up question (type /exit to end conversation):');

        // Check if the user wants to exit
        if (followUp.toLowerCase() === '/exit' ||
            followUp.toLowerCase() === '/quit' ||
            followUp.trim() === '') {
          console.log(chalk.green('Conversation ended. Thanks for using LLaMB!'));
          conversationActive = false;
          continue;
        }

        // Check for special slash commands
        if (followUp.startsWith('/')) {
          const slashCommand = followUp.substring(1);

        switch (slashCommand) {
          case 'clear':
            try {
              const sessionManager = SessionManager.getInstance();
              sessionManager.clearSession();
              console.log(chalk.green('Conversation context has been cleared.'));
              continue;
            } catch (error: any) {
              console.error(chalk.red('Error:'), error.message);
            }
            continue;

          case 'new':
            try {
              const sessionManager = SessionManager.getInstance();
              sessionManager.createNewSession();
              console.log(chalk.green('Started a new conversation context.'));
              continue;
            } catch (error: any) {
              console.error(chalk.red('Error:'), error.message);
            }
            continue;

          case 'history':
            try {
              const sessionManager = SessionManager.getInstance();
              const messages = sessionManager.getMessages();

              if (messages.length === 0) {
                console.log(chalk.yellow('No conversation history yet.'));
                continue;
              }

              console.log(chalk.bold('Conversation History:'));

              // Get terminal width for the output box
              const terminalWidth = process.stdout.columns || 80;
              const maxWidth = Math.min(terminalWidth - 10, 100);

              // Display each message with appropriate styling
              messages.forEach((message, index) => {
                const roleColor = message.role === 'user' ? chalk.blue : chalk.green;
                const roleName = message.role === 'user' ? 'You' : 'Assistant';

                console.log(roleColor(chalk.bold(`${roleName}:`)));

                // Create a boxed message
                const boxedMessage = boxen(wrap(message.content, { width: maxWidth - 4, indent: '' }), {
                  padding: 1,
                  borderColor: message.role === 'user' ? 'blue' : 'green',
                  borderStyle: 'round',
                  width: maxWidth,
                });

                console.log(boxedMessage);

                // Add spacing between messages
                if (index < messages.length - 1) {
                  console.log('');
                }
              });
            } catch (error: any) {
              console.error(chalk.red('Error:'), error.message);
            }
            continue;

          case 'file':
            try {
              // Ask for a file path
              const filePath = await customPrompt('Enter file path:');
              if (filePath.trim() === '') {
                console.log(chalk.yellow('File path cannot be empty.'));
                continue;
              }

              console.log(chalk.dim(`Reading file: ${filePath}`));
              currentFileContent = readFile(filePath);
              console.log(chalk.green(`‚úì File loaded (${(currentFileContent.length / 1024).toFixed(1)} KB)`));
              console.log(chalk.dim('Use /unfile to remove the attached file.'));
            } catch (error: any) {
              console.error(chalk.red(`Error reading file: ${error.message}`));
            }
            continue;

          case 'unfile':
            currentFileContent = undefined;
            console.log(chalk.green('‚úì File attachment removed.'));
            continue;

          case 'help':
            console.log(chalk.bold('Conversation Commands:'));
            console.log('  /exit, /quit           Exit the conversation');
            console.log('  /clear                 Clear conversation history');
            console.log('  /new                   Start a new conversation');
            console.log('  /history               View conversation history');
            console.log('  /file                  Attach a file to your next question');
            console.log('  /unfile                Remove attached file');
            console.log('  /help                  Show this help message');
            continue;
        }
      }

      // Set the current question and handle it
      currentQuestion = followUp;
      await handleQuestion(currentQuestion, options, currentFileContent);
      } catch (error: any) {
        console.error(chalk.red('Error in conversation:'), error);
        // Check if it's an inquirer termination error (usually Ctrl+C)
        if (error.isTtyError ||
            error.message?.includes('canceled') ||
            error.code === 'SIGINT' ||
            error.message?.includes('User force closed')) {
          console.log(chalk.yellow('\nConversation interrupted by user.'));
          console.log(chalk.green('Thanks for using LLaMB!'));
          process.exit(0); // Explicitly exit the process
        } else {
          // Log other errors but continue the conversation
          console.error(chalk.red('Error:'), error.message);
          continue;
        }
      }
    }

  } catch (error: any) {
    console.error(chalk.red('Error:'), error.message);
  }
}

// Handle an individual question (extracted to reduce code duplication)
async function handleQuestion(question: string, options: any, fileContent?: string) {
  try {
    // Check if the provider has a valid API key if needed
    const provider = await getProviderWithApiKey(options.provider);

    if (!provider.noAuth && !provider.apiKey) {
      console.log(chalk.yellow(`‚ö†Ô∏è  Provider '${provider.name}' requires an API key but none is set.`));
      console.log(chalk.cyan('To add an API key interactively, run:'));
      console.log(chalk.bold('  llamb provider:apikey'));
      console.log(chalk.cyan('To add an API key non-interactively, run:'));
      console.log(chalk.bold(`  llamb provider:apikey --provider ${provider.name} --key YOUR_API_KEY`));
      console.log(chalk.cyan('To add a new provider, run:'));
      console.log(chalk.bold('  llamb provider:add'));
      console.log(chalk.cyan('To list available providers, run:'));
      console.log(chalk.bold('  llamb providers'));
      console.log('');

      // Check if any local provider is available as a fallback
      const localProviders = getProviders().filter(p => p.noAuth === true);
      if (localProviders.length > 0) {
        console.log(chalk.green(`You can use a local provider without an API key, for example:`));
        console.log(chalk.bold(`llamb -p ${localProviders[0].name} "${question}"`));
      }
      throw new Error("No API key found");
    }

    // Get terminal width for the output box
    const terminalWidth = process.stdout.columns || 80;
    const maxWidth = Math.min(terminalWidth - 10, 100); // Account for padding and max reasonable width

    // Determine if we should stream (default to true unless explicitly set to false)
    const shouldStream = options.stream !== false;

    // Determine if we should use progress-only mode (prevents scrollback artifacts)
    // Check command-line options first, then fall back to config setting
    // --live-stream flag overrides both --progress-only and the config setting
    const useProgressOnly = options.liveStream === true ? false :
                          (options.progressOnly === true ||
                          (options.progressOnly !== false && config.get('useProgressOnly')));

    // Check if we should use the ink-based UI (enabled by default, can be disabled with --no-ink)
    const useInkUI = options.ink !== false && config.get('useInkUI') === true;

    let answer = '';

    if (shouldStream) {
      // If using Ink UI, it handles the streaming display
      if (useInkUI) {
        // Create an AbortController for cancellation support
        const abortController = new AbortController();

        // Create a streaming function for Ink to consume
        const streamingFunction = (onChunk: (chunk: string) => void) => {
          return askQuestionWithStreaming(
            question,
            onChunk,
            options.model,
            options.provider,
            options.baseUrl,
            options.history,
            fileContent,
            abortController
          );
        };

        // Use the ink-based UI for display with cancellation support
        const unmount = renderStreamingResponse(
          question,
          streamingFunction,
          (fullResponse: string) => {
            answer = fullResponse;
            // Handle file output when complete
            if (options.output !== undefined) {
              try {
                handleFileOutput(answer, options.output, options.overwrite);
              } catch (error: any) {
                console.error(chalk.red(`Error saving response: ${error.message}`));
              }
            }
          },
          abortController,
          options.chat // Pass the chat mode flag
        );

        // Handle Ctrl+C during streaming
        const sigintHandler = () => {
          // Abort the request
          abortController.abort();
          // Unmount the UI
          unmount();
          console.log(chalk.red('\nRequest cancelled by user'));
          // In continuous conversation mode, we want to throw an error to be caught by the parent
          if (options.chat) {
            throw new Error('User force closed');
          } else {
            // In non-chat mode, exit when done
            exitWhenDone()
          }
        };

        process.on('SIGINT', sigintHandler);

        // Wait for the streaming to complete before returning
        await new Promise<void>((resolve) => {
          const checkInterval = setInterval(() => {
            if (typeof answer !== 'undefined') {
              clearInterval(checkInterval);
              // Remove the SIGINT handler to avoid memory leaks
              process.removeListener('SIGINT', sigintHandler);
              resolve();
            }
          }, 100);
        });

        unmount();
        // Exit when done in non-chat mode
        if (!options.chat) {
          exitWhenDone();
        }

      } else if (useProgressOnly) {
        // PROGRESS-ONLY MODE: collect response and only render at the end
        // This eliminates all scrollback issues
        let partialResponse = '';
        let streamComplete = false;
        let updateCounter = 0;
        const streamInterval = 50; // ms between updates

        // Custom spinner alternating between lamb and llama emojis
        const animalEmojis = ['üêë', 'ü¶ô'];
        const spinner = ora({
          text: chalk.dim('Thinking...'),
          spinner: {
            frames: animalEmojis,
            interval: 400
          },
          color: 'yellow'
        }).start();

        // Display the question once
        console.log(chalk.dim('Asking: ') + question);

        // Collect the response through streaming without displaying intermediate updates
        const handleStreamingChunk = (chunk: string) => {
          partialResponse += chunk;
          updateCounter++;
        };

        // Start a timer that will update a progress indicator instead of the content
        const progressTimer = setInterval(() => {
          if (updateCounter > 0 && spinner.isSpinning) {
            spinner.text = chalk.dim(`Receiving response${'.'.repeat(updateCounter % 4)}`);
            updateCounter = 0;
          }

          if (streamComplete) {
            clearInterval(progressTimer);
          }
        }, streamInterval);

        // Set up the callback and ask the question
        answer = await askQuestionWithStreaming(
          question,
          handleStreamingChunk,
          options.model,
          options.provider,
          options.baseUrl,
          options.history,
          fileContent
        );

        // Mark streaming as complete and clear the interval
        streamComplete = true;
        clearInterval(progressTimer);

        // Stop the spinner
        spinner.stop();

        // Parse and display the full response at once
        //@ts-ignore
        const parsedResponse = marked(String(answer)) as string;
        const boxedResponse = boxen(parsedResponse, {
          padding: 1,
          borderColor: 'green',
          borderStyle: 'round',
          title: 'LLaMB',
          titleAlignment: 'center',
          width: maxWidth,
        });

        // Display the complete response once with no streaming artifacts
        console.log(boxedResponse);

        // Exit when done in non-chat mode
        if (!options.chat) {
          exitWhenDone();
        }
      } else {
        // LIVE STREAMING MODE: show content as it arrives (may have scrollback artifacts)
        let partialResponse = '';
        let isFirstChunk = true;

        // Custom spinner alternating between lamb and llama emojis
        const animalEmojis = ['üêë', 'ü¶ô'];
        const spinner = ora({
          text: chalk.dim('Thinking...'),
          spinner: {
            frames: animalEmojis,
            interval: 400
          },
          color: 'yellow'
        }).start();

        // Display the question once
        console.log(chalk.dim('Asking: ') + question);

        // Function to create a clean render of the response
        const renderResponse = (content: string) => {
          // Parse markdown
          //@ts-ignore
          const parsedContent = marked(content) as string;

          // Create the boxed response
          return boxen(parsedContent, {
            padding: 1,
            borderColor: 'green',
            borderStyle: 'round',
            title: 'LLaMB',
            titleAlignment: 'center',
            width: maxWidth,
          });
        };

        // Track the state for terminal rendering
        let lastOutputLines = 0;

        // Process streaming content with live updates
        const handleStreamingChunk = (chunk: string) => {
          // Stop the spinner on first chunk
          if (isFirstChunk) {
            spinner.stop();
            isFirstChunk = false;
          }

          // Accumulate the response
          partialResponse += chunk;

          // Render the response and store its line count
          const rendered = renderResponse(partialResponse);
          const renderedLines = rendered.split('\n').length;

          // Logic for first render vs subsequent renders
          if (lastOutputLines === 0) {
            // First render after spinner stops
            process.stdout.write(rendered + '\n');
          } else {
            // For subsequent renders:
            // 1. Move cursor up to beginning of last output
            process.stdout.write(`\x1B[${lastOutputLines}A`);
            // 2. Clear screen from cursor down (removes old content)
            process.stdout.write('\x1B[J');
            // 3. Write new content
            process.stdout.write(rendered + '\n');
          }

          // Store line count for next update
          lastOutputLines = renderedLines;
        };

        // Set up the callback and ask the question
        answer = await askQuestionWithStreaming(
          question,
          handleStreamingChunk,
          options.model,
          options.provider,
          options.baseUrl,
          options.history,
          fileContent
        );

        // Exit when done in non-chat mode
        if (!options.chat) {
          exitWhenDone();
        }
      }

      // Handle file output
      if (options.output !== undefined) {
        try {
          await handleFileOutput(answer, options.output, options.overwrite);
        } catch (error: any) {
          console.error(chalk.red(`Error saving response: ${error.message}`));
        }
      }

      // Exit when done in non-chat mode
      if (!options.chat) {
        exitWhenDone();
      }
    } else {
      // Non-streaming version - show spinner alternating between lamb and llama
      const animalEmojis = ['üêë', 'ü¶ô'];
      const spinner = ora({
        text: chalk.dim('Thinking...'),
        spinner: {
          frames: animalEmojis,
          interval: 400
        },
        color: 'yellow'
      }).start();

      // Call without streaming
      answer = await askQuestion(question, options.model, options.provider, options.baseUrl, options.history, fileContent);

      // Stop the spinner
      spinner.stop();

      // Make sure answer is a string before parsing markdown
      const answerText = typeof answer === 'string' ? answer : String(answer);

      // Parse markdown and apply syntax highlighting
      // Need to cast result to string since marked types are problematic
      //@ts-ignore
      const parsedMarkdown = marked(answerText) as string;

      // Create a styled box for the answer
      const boxedAnswer = boxen(parsedMarkdown, {
        padding: 1,
        borderColor: 'green',
        borderStyle: 'round',
        title: 'LLaMB',
        titleAlignment: 'center',
        width: maxWidth,
      });

      console.log(boxedAnswer);

      // Handle file output
      if (options.output !== undefined) {
        try {
          await handleFileOutput(answerText, options.output, options.overwrite);
        } catch (error: any) {
          console.error(chalk.red(`Error saving response: ${error.message}`));
        }
      }

      // Exit when done in non-chat mode
      if (!options.chat) {
        exitWhenDone();
      }
    }
  } catch (error: any) {
    if (error.message.includes('No API key found')) {
      // Provide helpful setup instructions
      console.log(chalk.yellow('‚ö†Ô∏è  You need to configure an LLM provider.'));
      console.log(chalk.cyan('Add a provider: ') + chalk.bold('llamb provider:add'));
      
      // Check if Ollama is configured
      const providers = getProviders();
      const ollama = providers.find(p => p.name === 'ollama');
      if (ollama) {
        console.log(chalk.green(`Try Ollama: `) + chalk.bold(`llamb -p ollama "${question}"`));
      }
    } else if (error.message.includes('appears to be offline') || error.message.includes('unreachable')) {
      // Provider offline error
      console.log(chalk.yellow('‚ö†Ô∏è  ' + error.message));
      
      // Get all available providers to suggest alternatives
      const providers = getProviders();
      const currentProvider = providers.find(p => p.name === options.provider || getDefaultProvider());
      const otherProviders = providers.filter(p => p.name !== currentProvider?.name);
      
      if (otherProviders.length > 0) {
        let readyProviders = 0;
        for (const provider of otherProviders) {
          const hasApiKey = provider.noAuth ? true : await KeyManager.getApiKey(provider.name);
          if (hasApiKey || provider.noAuth) {
            console.log(chalk.cyan(`Try: `) + chalk.bold(`llamb -p ${provider.name} "${question}"`));
            readyProviders++;
            if (readyProviders >= 2) break; // Limit to just 2 suggestions
          }
        }
        
        if (readyProviders === 0) {
          console.log(chalk.cyan('Change provider: ') + chalk.bold('llamb provider:default'));
        }
      } else {
        console.log(chalk.cyan('Add new provider: ') + chalk.bold('llamb provider:add'));
      }
    } else if (error.message.includes('Failed to get response from')) {
      // General provider error
      console.log(chalk.yellow('‚ö†Ô∏è  ' + error.message));
      console.log(chalk.cyan('Try: ') + chalk.bold('llamb provider:default'));
    } else {
      console.error(chalk.red('Error:'), error.message);
    }

    // Exit when done in non-chat mode with error code
    if (!options.chat) {
      exitWhenDone(1); // Exit with error code 1
    }
  }
}

// Process the command line arguments
program.parse(process.argv);

// If no arguments, show help
if (process.argv.length <= 2) {
  program.outputHelp();
}